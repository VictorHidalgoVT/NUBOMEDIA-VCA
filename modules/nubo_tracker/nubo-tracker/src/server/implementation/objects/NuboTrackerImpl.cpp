/* Autogenerated with kurento-module-creator */

#include <gst/gst.h>
#include <vector>
#include <TrackerInfo.hpp> 
#include "MediaPipeline.hpp"
#include "MediaPipelineImpl.hpp"
#include <NuboTrackerImplFactory.hpp>
#include "NuboTrackerImpl.hpp"
#include <jsonrpc/JsonSerializer.hpp>
#include <KurentoException.hpp>
#include <SignalHandler.hpp>

#define GST_CAT_DEFAULT kurento_nubo_tracker_impl
GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
#define GST_DEFAULT_NAME "KurentoNuboTrackerImpl"

#define SET_THRESHOLD "set_threshold"
#define SET_MIN_AREA "set_min_area"
#define SET_MAX_AREA "set_max_area"
#define SET_DISTANCE "set_distance"
#define SET_VISUAL_MODE "set_visual_mode"
#define ACTIVATE_EVENTS "activate-events"
#define EVENTS_MS "events-ms"

namespace kurento
{
namespace module
{
namespace nubotracker
{


      void  NuboTrackerImpl::split_message (std::string fi, std::string delimiter, 
					     std::vector<std::string> *v)
      {
	size_t pos = 0;
	std::string token;
	
	while ((pos = fi.find(delimiter)) != std::string::npos) {
	  token = fi.substr(0, pos);  
	  v->push_back(token);
	  fi.erase(0, pos + delimiter.length());
	}
	
	v->push_back(fi);
	
      }
      
      void NuboTrackerImpl::onTracker (gchar *message)
      {

	/*the String received will be like this ( the ; is the seperation among objects): 
	  x:int,y:int,width:int,height:int;x:int,y:int,width:int,height:int;*/
	std::string del1 = ";";
	std::string del2 = ",";
	std::string del3 = ":";
	std::vector<std::string> *objs = new std::vector<std::string>;
	std::vector<std::string> *fields = new std::vector<std::string>;
	std::vector<std::string> *all = new std::vector<std::string>;
	std::vector<std::shared_ptr<TrackerInfo>> test;
	int x,y,height,width;
	std::string t;
	int size=0;

  
	bool register_completed=true;
	int i=0;
	try {

	  split_message(message,del1,objs);
	  for( i=0; (int)(objs->size())>i; i++) 
	    split_message(objs->at(i),del2,fields);
    
	  for( i=0; (int)(fields->size())>i; i++)
	    split_message(fields->at(i),del3,all);
    
	  TrackerInfo *ti;
	  
	  for(int i=0; (int)(all->size())>i; i=i+2)
	    {
	
	      if (register_completed)
		{
		  t="tracker";
		  x=0;y=0;width=0;height=0;
		  register_completed=false;
		}
	      if (0==all->at(i).compare("x")) 	
		{
		  if ((i+1)< (int)(all->size()))	      
		    x=std::stoi(all->at(i+1));
		}
	      else if (0==all->at(i).compare("y")) 
		{
		  if ((i+1)< (int)(all->size()))
		    y=std::stoi(all->at(i+1));
		}
	
	      else if (0==all->at(i).compare("width"))     
		{
		  if ((i+1)< (int)(all->size()))
		    width=(std::stoi(all->at(i+1)));
		}
	      else if (0==all->at(i).compare("height"))     
		{
		  if ((i+1)< (int)(all->size()))
		    {
		      size++;
		      height=std::stoi(all->at(i+1));
		      std::shared_ptr <TrackerInfo> cand ( new TrackerInfo(t,x,y,width,height));
		      test.push_back(cand);
		      register_completed=true;
		    }
		}
	    }

	  if (test.size()>0)
	    {
	      OnTracker event (shared_from_this(), OnTracker::getName(), test);
	      signalOnTracker (event);
	    }
	} catch (std::bad_weak_ptr &e) {
	}
      }

      
      void NuboTrackerImpl::postConstructor ()
      {
	handlerOnTrackerEvent = register_signal_handler (G_OBJECT (nubo_tracker),
			      "tracker-event",
			       std::function <void (GstElement *, gchar *) >
			       (std::bind (&NuboTrackerImpl::onTracker, this,
			        std::placeholders::_2) ),
			       std::dynamic_pointer_cast<NuboTrackerImpl>
			      (shared_from_this() ) );
      }


  NuboTrackerImpl::NuboTrackerImpl (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline)  :  FilterImpl (config, std::dynamic_pointer_cast<MediaPipelineImpl> (mediaPipeline)) 
{
  	g_object_set (element, "filter-factory", "nubotracker", NULL);

	g_object_get (G_OBJECT (element), "filter", &nubo_tracker, NULL);

	if (NULL == nubo_tracker) {
	  throw KurentoException (MEDIA_OBJECT_NOT_AVAILABLE,
				  "Media Object not available");
	}
	handlerOnTrackerEvent = 0;
	g_object_unref(nubo_tracker);
}


void NuboTrackerImpl::setThreshold(int threshold)
{
  g_object_set(G_OBJECT(nubo_tracker),SET_THRESHOLD,threshold,NULL);
}

void NuboTrackerImpl::setMinArea(int minArea)
{
g_object_set(G_OBJECT(nubo_tracker),SET_MIN_AREA,minArea,NULL);
}


void NuboTrackerImpl::setMaxArea(float maxArea)
{
long m_area=maxArea;

g_object_set(G_OBJECT(nubo_tracker),SET_MAX_AREA,m_area,NULL);
}

void NuboTrackerImpl::setDistance(int distance)
{ 
  g_object_set(G_OBJECT(nubo_tracker),SET_DISTANCE,distance,NULL);
}

void NuboTrackerImpl::setVisualMode(int mode){
  g_object_set(G_OBJECT(nubo_tracker),SET_VISUAL_MODE,mode,NULL);
}

  void NuboTrackerImpl::activateServerEvents (int activate,int ms)
  {
    g_object_set (G_OBJECT (nubo_tracker), ACTIVATE_EVENTS , activate, NULL);
    g_object_set (G_OBJECT (nubo_tracker), EVENTS_MS , ms , NULL);
  
}
MediaObjectImpl *
NuboTrackerImplFactory::createObject (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline) const
{

  return new NuboTrackerImpl (config, mediaPipeline);
}

NuboTrackerImpl::StaticConstructor NuboTrackerImpl::staticConstructor;

NuboTrackerImpl::StaticConstructor::StaticConstructor()
{
  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, GST_DEFAULT_NAME, 0,
                           GST_DEFAULT_NAME);
}

NuboTrackerImpl::~NuboTrackerImpl()
{
  if ( handlerOnTrackerEvent > 0) {
    unregister_signal_handler (nubo_tracker, handlerOnTrackerEvent );
  }
}
} /* nubotracker */
} /* module */
} /* kurento */
